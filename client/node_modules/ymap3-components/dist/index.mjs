import s, { createContext as f, useLayoutEffect as h, useEffect as C, useContext as y, useState as M, useMemo as D } from "react";
import Y from "react-dom";
const d = f({}), w = typeof document < "u" ? h : C;
function o(t, r) {
  let n;
  const l = ({ ...e }, p) => {
    const { reactify: a, ymaps: i } = y(
      d
    ), [x, m] = M(!1);
    return w(() => {
      r ? window[r] ? (m(!0), n = a.module(window[r])[t]) : i.import(r).then((u) => {
        window[r] = u, a.module(u) && (m(!0), n = a.module(u)[t]);
      }) : (n = a.module(i)[t], m(!0));
    }, []), !n || !x ? null : /* @__PURE__ */ s.createElement(n, { ref: p, ...e });
  };
  return s.forwardRef(l);
}
const H = async (t, r = "ru_RU") => new Promise(async (n, l) => {
  if (window.ymaps3) {
    const e = window.ymaps3;
    await e.ready;
    const a = (await e.import("@yandex/ymaps3-reactify")).reactify.bindTo(s, Y);
    a.module(e), n({
      ymaps: e,
      reactify: a
    });
  } else {
    const e = document.createElement("script");
    document.body.appendChild(e), e.type = "text/javascript", e.src = `https://api-maps.yandex.ru/v3/?apikey=${t}&lang=${r}`, e.onload = async () => {
      const p = window.ymaps3;
      await p.ready;
      const i = (await p.import("@yandex/ymaps3-reactify")).reactify.bindTo(s, Y);
      n({
        ymaps: p,
        reactify: i
      });
    }, e.onerror = l;
  }
}), L = ({
  apiKey: t,
  lang: r,
  children: n,
  onLoad: l
}) => {
  const [e, p] = M();
  return w(() => {
    H(t, r).then((a) => {
      p(a), l && l(a);
    });
  }, []), e ? /* @__PURE__ */ s.createElement(d.Provider, { value: e }, n) : /* @__PURE__ */ s.createElement(s.Fragment, null);
}, R = s.memo(L);
var c = /* @__PURE__ */ ((t) => (t.CartesianProjection = "@yandex/ymaps3-cartesian-projection@0.0.1", t.Clusterer = "@yandex/ymaps3-clusterer@0.0.1", t.Controls = "@yandex/ymaps3-controls@0.0.1", t.Hint = "@yandex/ymaps3-hint@0.0.1", t.Markers = "@yandex/ymaps3-markers@0.0.1", t.SphericalMercatorProjection = "@yandex/ymaps3-spherical-mercator-projection@0.0.1", t))(c || {});
const S = f({
  hint: void 0
}), E = ({
  children: t,
  context: r
}) => {
  const n = y(r);
  return /* @__PURE__ */ s.createElement(S.Provider, { value: n }, t);
}, T = ({ children: t, hint: r }) => {
  const { reactify: n, ymaps: l } = y(
    d
  ), [e, p] = M(), a = D(() => {
    if (e) {
      const i = window[c.Hint];
      return n.module(i).YMapHint;
    }
  }, [e]);
  return C(() => {
    if (window[c.Hint]) {
      const i = window[c.Hint];
      p(n.module(i).YMapHintContext);
    } else
      l.import(c.Hint).then((i) => {
        window[c.Hint] = i, n.module(i) && p(n.module(i).YMapHintContext);
      });
  }, []), !a || !e || !t ? /* @__PURE__ */ s.createElement(s.Fragment, null) : /* @__PURE__ */ s.createElement(a, { hint: r }, /* @__PURE__ */ s.createElement(E, { context: e }, t));
}, j = o("YMapGeolocationControl", c.Controls), b = o("YMapZoomControl", c.Controls), $ = o("YMapClusterer", c.Clusterer), B = o("YMapDefaultMarker", c.Markers), G = o("YMap"), I = o("YMapTileDataSource"), W = o("ThemeContext"), Z = o("YMapControl"), O = o("YMapLayer"), U = o("YMapMarker"), _ = o("YMapDefaultSchemeLayer"), q = o("YMapDefaultFeaturesLayer"), z = o("YMapDefaultSatelliteLayer"), A = o("YMapListener"), J = o("YMapControls"), K = o("YMapControlButton"), Q = o("YMapContainer"), V = o("YMapCollection"), X = o("YMapFeature"), k = o("YMapFeatureDataSource");
export {
  W as ThemeContext,
  G as YMap,
  $ as YMapClusterer,
  V as YMapCollection,
  R as YMapComponentsProvider,
  Q as YMapContainer,
  Z as YMapControl,
  K as YMapControlButton,
  J as YMapControls,
  q as YMapDefaultFeaturesLayer,
  B as YMapDefaultMarker,
  z as YMapDefaultSatelliteLayer,
  _ as YMapDefaultSchemeLayer,
  X as YMapFeature,
  k as YMapFeatureDataSource,
  j as YMapGeolocationControl,
  T as YMapHint,
  S as YMapHintContext,
  O as YMapLayer,
  A as YMapListener,
  U as YMapMarker,
  I as YMapTileDataSource,
  b as YMapZoomControl
};
